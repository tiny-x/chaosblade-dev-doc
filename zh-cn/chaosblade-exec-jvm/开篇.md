# 混沌工程 Java应用实验场景

## 前言

近些年，软件系统设计不断往分布式系统设计方向发展，遵循软件设计“高内聚、低耦合”的原则将系统模块化拆分。但是也带来了一些问题，如服务的繁忙、服务的异常、网络的延迟、数据的一致性等。为了解决这些问题我们需要做一些事情，如引入缓存、限流等措施，而混沌工程实验可以让我们更好得做好这些事情，提高系统的可用性。

本文将详细介绍Chaosblade-exec-jvm的整体架构设计，使用户对Chaosblade-exec-jvm有一定的了解，后续分别详细介绍`chaosblade` 与 `chaosblade-exec-jvm` 之间通信协议、`chaosblade-exec-jvm`混沌实验模型、`chaosblade-exec-jvm`插件、`Java Agent`和字节码相关、插件的开发实战，方便用户扩展自定义的Java故障场景能力，支持更丰富的故障场景，及贡献代码共同推进混沌工程领域的发展。

## 项目介绍

ChaosBlade 是阿里巴巴开源的一款遵循混沌工程原理和混沌实验模型的实验注入工具，帮助企业提升分布式系统的容错能力，并且在企业上云或往云原生系统迁移过程中业务连续性保障。

Chaosblade-exec-jvm 遵循与ChaosBlade的通信写协议，是Java 应用混沌工程实验场景实现，托管在 Github 平台，放在 chaosblade-io 组织下，方便项目管理和社区发展。Chaosblade-exec-jvm使用 Java Agent 技术动态挂载，无需任何接入，零成本使用，而且支持卸载，完全回收 Agent 创建的各种资源。


## 系统设计

Chaosblade-exec-jvm遵循混沌实验模型设计，通过插件的可拔插设计来扩展对不同Java组件的支持，可以很方便的扩展插件来支持更多的故障场景，插件基于AOP的设计定义通知`Advice`、增强类`Enhancer`、切点`PointCut`，同时结合混沌实验模型定模型`ModelSpec`、实验靶点`Target`、匹配方式`Matcher`、攻击动作`Action`。

Chaosblade-exec-jvm在由`make builde`编译打包时下载`jvm-sandbox relase`包，编译打包后Chaosblade-exec-jvm做为jvm-sandbox的模块。在加载Agent后，同时监听jvm-sandbox的事件来管理整个混沌实验流程，通过Java Agent 技术来实现类的transform注入故障。

### 实现原理

Chaosblade-exec-jvm通过JavaAgent attach方式来实现类的transform注入故障，以servlet，api的接口延迟为例，实现原理如下图：

![ 原理图](../images/delay-design.jpg)

### 工程分类

- `chaosblade-exec-bootstrap`依赖jvm-sandbox，启动监听相关
- `chaosblade-exec-common`通用模块
- `chaosblade-exec-plugin`可扩展的插件，支持的故障能力
- `chaosblade-exec-service`jvm-sandbox http命令处理和yaml的创建，yaml是与ChaosBlade协议对接的载体

### 模块分类

Chaosblade-exec-jvm模块化管理插件、模型的生命周期以及混沌实验的状态。

#### SandboxModule

`com.alibaba.chaosblade.exec.bootstrap.jvmsandbox.SandboxModule`做为jvm-sandbox的模块，通过jvm-sandbox来加载。同时监听jvm-sandbox的事件。jvm-sandbox内置jetty容器，访问api回调到注解为@Http("/xx")的方法，来实现故障能力的注入和销毁。

|jvm-sandbox事件|Chaosblade-exec-jvm触发的行为|
|  ----  | ----  |
|Agent加载（onLoad）| ManagerFactory加载 |
|Agent卸载（onUnload）|ManagerFactory卸载|
|模块激活（onActive）|加载插件|
|模块冻结（onFrozen）|-|
|加载完成（loadCompleted）|日志记录|
#### StatusManager

Chaosblade-exec-jvm通过`com.alibaba.chaosblade.exec.common.center.StatusManager`类来管理混沌实验的状，Chaosblade下发`blade create `命令后在StatusManager注册本次实验状，保存混沌实验的模型、参数匹配、攻击的靶点、攻击行为、攻击次数、攻击的百分比等。

#### ModelSpecManager

Chaosblade-exec-jvm通过`com.alibaba.chaosblade.exec.common.center.ModelSpecManager`来管理插件对应的混沌实验模型，模型随着插件的加载而加载，插件的卸载而卸载。

#### ListenerManager

Chaosblade-exec-jvm通过`com.alibaba.chaosblade.exec.common.center.ListenerManager`管理插件的生命周期，插件的加载、卸载，插件加载后会在jvm-sandbox注册监听。

#### RequestHandler

Chaosblade-exec-jvm通过`com.alibaba.chaosblade.exec.service.handler.RequestHandler`来处理jvm-sandbox的http事件，jvm-sandbox内置jetty容器，访问api回调到注解为@Http("/xx")的方法，由事件分发器`DispatchService`将事件分到对应的`RequestHandler`处理，`RequestHandler`实例包含如下：

|命令|RequestHandler|
|  ----  | ----  |
|blade create| CreateHandler创建一个实验，StatusManager注册状态，满足一定条件的插件加载。 |
|blade status|StatusHandler去StatusManager查询实验状态。|
|blade destroy|DestroyHandler销毁实验，满足一定条件的插件卸载。|
**注意：表格中的【一定条件】可以参考下面的plugin加载方式 **

#### Inject

`com.alibaba.chaosblade.exec.common.injection.Injector`在故障能力注入前，从StatusManager获取混沌实验的状态，进行参数的比对，控制攻击的次数和百分比，调用ActionExecutor进行故障能力注入。jvm oom等直接注入的故障不进过Inject处理。

### 编译

Chaosblade-exec-jvm虽然使用maven构建，但是由于依赖jvm-sandbox，所以使用`make`编译打包，在项目根目录下进入项目执行:

````shell
make build
````

`make build`分为如下步骤：

- 下载并解压jvm-sandbox
- maven打包Chaosblade-exec-jvm
- `com.alibaba.chaosblade.exec.service.build.SpecMain`生成`yaml`

编译成功后，在当前目录生成如下`yaml`和`jar`

- `plugins/chaosblade-jvm-spec-0.6.0.yaml`
- `build-target/chaosblade-0.6.0/lib/sandbox/module/chaosblade-java-agent-0.6.0.jar`

**分别将`yml`和`jar`替换到如下图的`chaosblade`目录下：**
![](../images/chaos-blade-path.png)

## 实验步骤

在上面编译并且拷贝成功后即可Chaosblade命令来执行混沌实验，通过下面通过命令拆解来介绍每个步骤是如何实现，以servlet，api的接口延迟为例，演练实验的步骤大致如下：

````shell
./blade p jvm --pid 888
{"code":200,"success":true,"result":"98e792c9a9a5dfea"}

./blade create servlet --requestpath=/topic delay --time=3000
{"code":200,"success":true,"result":"52a27bafc252beee"}

./blade destroy 52a27bafc252beee

./blade revoke 98e792c9a9a5dfea
````

### Agent挂载

````shell
./blade p jvm --pid 888
````

该命令下发后，将在目标jvm进程挂在Agent，触发SandboxModule onLoad()事件，初始化PluginLifecycleListener来管理插件的生命周期，同时也触发SandboxModule onActive()事件，加载部分插件，加载插件对应的ModelSpec。

#### Plugin加载方式

|加载方式|加载条件|
|  ----  | ----  |
|SandboxModule onActive()事件|Pointcut、ClassMatcher、MethodMatcher都不为空|
|blade create命令CreateHandler|ModelSpect为PreCreateInjectionModelHandler类型，且ActionFlag 不为DirectlyInjectionAction类型|

Plugin加载时，创建事件监听器SandboxEnhancerFactory.createAfterEventListener(plugin)，监听器会监听感兴趣的事件，如BeforeAdvice、AfterAdvice等，具体实现如下：

````java
// 加载插件
public void add(PluginBean plugin) {
    PointCut pointCut = plugin.getPointCut();
    if (pointCut == null) {
        return;
    }
    String enhancerName = plugin.getEnhancer().getClass().getSimpleName();
    // 创建filter PointCut匹配
    Filter filter = SandboxEnhancerFactory.createFilter(enhancerName, pointCut);

    if (plugin.isAfterEvent()) {
        // 事件监听
        int watcherId = moduleEventWatcher.watch(filter, SandboxEnhancerFactory.createAfterEventListener(plugin),
            Type.BEFORE, Type.RETURN);
        watchIds.put(PluginUtil.getIdentifierForAfterEvent(plugin), watcherId);
    } else {
        int watcherId = moduleEventWatcher.watch(
            filter, SandboxEnhancerFactory.createBeforeEventListener(plugin), Event.Type.BEFORE);
        watchIds.put(PluginUtil.getIdentifier(plugin), watcherId);
    }
}
````

#### PointCut匹配

- SandboxModule onActive()事件触发Plugin加载后，SandboxEnhancerFactory创建filter，filter内部通过PointCut的ClassMatcher和MethodMatcher过滤。

#### Enhancer

如果已经加载插件，此时目标应用匹配能匹配到filter后，EventListener已经可以被触发，但是Chaosblade-exec-jvm内部通过StatusManager管理状态，所以故障能力不会被触发。

例如BeforeEventListener触发调用BeforeEnhancer的beforeAdvice方法，在ManagerFactory.getStatusManager().expExists(targetName)判断时候被中断，具体的实现如下：

````java
com.alibaba.chaosblade.exec.common.aop.BeforeEnhancer

public void beforeAdvice(String targetName, 
        ClassLoader classLoader, 
        String className,
        Object object,
        Method method, 
        Object[] methodArguments) throws Exception {
        // StatusManager 
    if (!ManagerFactory.getStatusManager().expExists(targetName)) {
        return;
    }
    EnhancerModel model = doBeforeAdvice(classLoader, className, object, method, methodArguments);
    if (model == null) {
        return;
    }
    model.setTarget(targetName).setMethod(method).setObject(object).setMethodArguments(methodArguments);
    Injector.inject(model);
}
````

### 创建混沌实验

````shell
./blade create servlet --requestpath=/topic delay --time=3000
````
该命令下发后，触发SandboxModule @Http("/create")注解标记的方法，将事件分发给`com.alibaba.chaosblade.exec.service.handler.CreateHandler`处理
在判断必要的uid、target、action、model参数后调用handleInjection，handleInjection通过状态管理器注册本次实验，如果插件类型是PreCreateInjectionModelHandler的类型，将预处理一些东西。同是如果Action类型是DirectlyInjectionAction，那么将直接进行故障能力注入，且不需要走Enhancer，如jvm oom等，如果不是那么将加载插件。

#### ModelSpec
- `com.alibaba.chaosblade.exec.common.model.handler.PreCreateInjectionModelHandler`预创建
- `com.alibaba.chaosblade.exec.common.model.handler.PreDestroyInjectionModelHandler`预销毁
#### DirectlyInjectionAction

如果ModelSpec是PreCreateInjectionModelHandler类型，且ActionSpec的类型是DirectlyInjectionAction类型，将直接进行故障能力注入，比如JvmOom故障能力，ActionSpec的类型不是DirectlyInjectionAction类型，将加载插件。


|  | DirectlyInjectionAction |Not DirectlyInjectionAction|
|  ----  | ----  | ----  |
| PreCreateInjectionModelHandler（ModelSpec） | 直接进行故障能力注入 |加载插件|
| PreDestroyInjectionModelHandler（ModelSpec） | 停止故障能力注入 |卸载插件|

````java
private Response handleInjection(String suid, Model model, ModelSpec modelSpec) {
    // 注册
    RegisterResult result = this.statusManager.registerExp(suid, model);
    if (result.isSuccess()) {
        // handle injection
        try {
            applyPreInjectionModelHandler(suid, modelSpec, model);
        } catch (ExperimentException ex) {
            this.statusManager.removeExp(suid);
            return Response.ofFailure(Response.Code.SERVER_ERROR, ex.getMessage());
        }

        return Response.ofSuccess(model.toString());
    }
    return Response.ofFailure(Response.Code.DUPLICATE_INJECTION, "the experiment exists");
}
````

注册成功后返回uid，如果本阶段直接进行故障能力注入了，或者自定义Enhancer advice返回null，那么后不通过Inject类触发故障。

### 故障能力注入

故障能力注入的方式，最终都是调用ActionExecutor执行故障能力。

- 通过Injector注入。
- DirectlyInjectionAction直接注入，直接注入不进过Inject类调用阶段，如果jvm oom等。

DirectlyInjectionAction直接注入不经过Enhancer参数包装匹配直接到故障触发ActionExecutor执行阶段，如果是Injector注入此时因为StatusManager已经注册了实验，当事件再次出发后ManagerFactory.getStatusManager().expExists(targetName)的判断不会被中断，继续往下走，到了自定义的Enhancer，在自定义的Enhancer里面可以拿到原方法的参数、类型等，甚至可以反射调原类型的其他方法，这样做风险较大，一般在这里往往是取一些成员变量或者get方法等，用于Injector阶段参数匹配。

#### 匹配参数包装

自定义的Enhancer，如ServletEnhancer，把一些需要与命令行匹配的参数 包装在MatcherModel里面，然后包装EnhancerModel返回，比如  --requestpath = /index，那么requestpath等于requestURI；--querystring="name=xx"做自定义匹配。参数包装好后，在 Injector.inject(model)阶段判断。

````java
public EnhancerModel doBeforeAdvice(ClassLoader classLoader, String className, Object object,
                                    Method method, Object[] methodArguments)
        throws Exception {
    Object request = methodArguments[0];
    String requestURI = ReflectUtil.invokeMethod(request, ServletConstant.GET_REQUEST_URI, new Object[]{}, false);
    String requestMethod = ReflectUtil.invokeMethod(request, ServletConstant.GET_METHOD, new Object[]{}, false);

    MatcherModel matcherModel = new MatcherModel();
    matcherModel.add(ServletConstant.METHOD_KEY, requestMethod);
    matcherModel.add(ServletConstant.REQUEST_PATH_KEY, requestURI);
    LOOGER.debug("servlet matchers: {}", JSON.toJSONString(matcherModel));

    Map<String, Object> queryString = getQueryString(requestMethod, request);
    LOOGER.debug("origin params: {}", JSON.toJSONString(queryString));

    EnhancerModel enhancerModel = new EnhancerModel(classLoader, matcherModel);
    enhancerModel.addCustomMatcher(ServletConstant.QUERY_STRING_KEY, queryString, ServletParamsMatcher.getInstance());
    return enhancerModel;
}
````

####  参数匹配和能力注入（Inject调用）

inject阶段首先获取StatusManager注册的实验，compare(model, enhancerModel)经常参数比对，失败后return，limitAndIncrease(statusMetric)判断 --effect-count --effect-percent来控制影响的次数和百分比

````java
public static void inject(EnhancerModel enhancerModel) throws InterruptProcessException {
    String target = enhancerModel.getTarget();
    List<StatusMetric> statusMetrics = ManagerFactory.getStatusManager().getExpByTarget(
        target);
    for (StatusMetric statusMetric : statusMetrics) {
        Model model = statusMetric.getModel();
        if (!compare(model, enhancerModel)) {
            continue;
        }
        try {
            boolean pass = limitAndIncrease(statusMetric);
            if (!pass) {
                LOGGER.info("Limited by: {}", JSON.toJSONString(model));
                break;
            }
            LOGGER.info("Match rule: {}", JSON.toJSONString(model));
            enhancerModel.merge(model);
            ModelSpec modelSpec = ManagerFactory.getModelSpecManager().getModelSpec(target);
            ActionSpec actionSpec = modelSpec.getActionSpec(model.getActionName());
            actionSpec.getActionExecutor().run(enhancerModel);
        } catch (InterruptProcessException e) {
            throw e;
        } catch (UnsupportedReturnTypeException e) {
            LOGGER.warn("unsupported return type for return experiment", e);
            statusMetric.decrease();
        } catch (Throwable e) {
            LOGGER.warn("inject exception", e);          
            statusMetric.decrease();
        }
        break;
    }
}
````

#### 故障触发

由Inject触发，或者有DirectlyInjectionAction直接触发，最后调用自定义的ActionExecutor生成故障，如 DefaultDelayExecutor，此时故障能力已经生效了。

```java
public void run(EnhancerModel enhancerModel) throws Exception {
    String time = enhancerModel.getActionFlag(timeFlagSpec.getName());
    Integer sleepTimeInMillis = Integer.valueOf(time);
    int offset = 0;
    String offsetTime = enhancerModel.getActionFlag(timeOffsetFlagSpec.getName());
    if (!StringUtil.isBlank(offsetTime)) {
        offset = Integer.valueOf(offsetTime);
    }
    TimeoutExecutor timeoutExecutor = enhancerModel.getTimeoutExecutor();
    if (timeoutExecutor != null) {
        long timeoutInMillis = timeoutExecutor.getTimeoutInMillis();
        if (timeoutInMillis > 0 && timeoutInMillis < sleepTimeInMillis) {
            sleep(timeoutInMillis, 0);
            timeoutExecutor.run(enhancerModel);
            return;
        }
    }
    sleep(sleepTimeInMillis, offset);
}

public void sleep(long timeInMillis, int offsetInMillis) {
    Random random = new Random();
    int offset = 0;
    if (offsetInMillis > 0) {
        offset = random.nextInt(offsetInMillis);
    }
    if (offset % 2 == 0) {
        timeInMillis = timeInMillis + offset;
    } else {
        timeInMillis = timeInMillis - offset;
    }
    if (timeInMillis <= 0) {
        timeInMillis = offsetInMillis;
    }
    try {
        // 触发延迟
        TimeUnit.MILLISECONDS.sleep(timeInMillis);
    } catch (InterruptedException e) {
        LOGGER.error("running delay action interrupted", e);
    }
}
```
### 销毁实验
````shell
./blade destroy 52a27bafc252beee
````
该命令下发后，触发SandboxModule @Http("/destory")注解标记的方法，将事件分发给com.alibaba.chaosblade.exec.service.handler.DestroyHandler处理。注销本次故障的状态。

如果插件的ModelSpec是PreDestroyInjectionModelHandler类型，且ActionSpec的类型是DirectlyInjectionAction类型，停止故障能力注入，ActionSpec的类型不是DirectlyInjectionAction类型，将卸载插件。

````java
public Response handle(Request request) {
    String uid = request.getParam("suid");
    String target = request.getParam("target");
    String action = request.getParam("action");
    if (StringUtil.isBlank(uid)) {
        if (StringUtil.isBlank(target) || StringUtil.isBlank(action)) {
            return Response.ofFailure(Code.ILLEGAL_PARAMETER, "less necessary parameters, such as uid, target and"
                + " action");
        }
        // 注销status
        return destroy(target, action);
    }
    return destroy(uid);
}
````
### 卸载Agent
````shell
./blade revoke 98e792c9a9a5dfea
````
该命令下发后，触发SandboxModule unload()事件，同时插件卸载，完全回收 Agent 创建的各种资源。

```java
public void onUnload() throws Throwable {
    LOGGER.info("unload chaosblade module");
    dispatchService.unload();
    ManagerFactory.unload();
    watchIds.clear();
    LOGGER.info("unload chaosblade module successfully");
}
```

## 总结

本文介绍了Chaosblade-exec-jvm项目的整体架构设计，通过对一次混沌实验的命令拆分，分析了Chaosblade-exec-jvm如何执行混沌实验，后续分别详细介绍`chaosblade` 与 `chaosblade-exec-jvm` 之间通信协议、`chaosblade-exec-jvm`混沌实验模型、`chaosblade-exec-jvm`插件、`Java Agent`和字节码相关、插件的开发实战。

